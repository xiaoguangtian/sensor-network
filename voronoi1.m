clear
clc
x=[48.3538587913173,1.61844169715975,17.9721536845270,31.0521860337423,74.7019916070261,58.5084408779129,70.4195111296323,80.6617780879627,85.3465386558057,12.6543746365076,66.0691019297548,75.5421957464037,70.5107502020770,60.9067269190967,4.78839591611987,20.3198589720674,33.7374881351947,64.6405067638594,22.5229888336980,8.61407097695239,98.0783461997517,21.4691372244351,98.3420805661261,61.4267303801344,25.5498767018482,52.2778350217767,71.5702743534005,26.7270337125167,12.3539145911411,55.4172801625140,22.6712748176368,31.9053828367872,97.3401751999232,31.6098585589561,94.6785028388520,41.6456247952387,2.02302655208136,31.6968307307141,16.3654769261437,99.4141714824343,45.5736812566866,54.9766104711435,26.9708460251257,88.3715822236886,11.2030461188385,82.5327062630158,43.2903973132103,92.1141235769696,53.2732037230581,87.2126293383082,35.9282702502294,40.6150887408407,60.1943661592453,91.2402748885154,14.1657148941789,5.17457432309194,40.7028571357895,59.9750610574827,92.0482503420710,30.0838054121704];
y=[54.9588948994518,78.3864960495067,33.4125546305476,10.4310140684431,44.7265786220647,3.87860515674766,67.8636477125628,12.0474469649417,20.7643878077245,53.4859923224447,63.1083278757819,37.9860665908608,61.0389097679023,84.7924797697859,70.4926232318103,39.8945175276062,57.6149976395565,25.7275997831899,73.0073265780287,34.9895853905802,8.78483281146269,30.9208618991692,30.7398457104757,3.29889856206683,18.4353109141129,86.2309608644916,65.9388687838220,85.7972225308405,27.8231061153965,89.6988301825875,21.6702491913658,96.4526498443598,42.0216487158776,23.7269561724927,82.0186496975110,36.6839058329456,50.6508827467938,75.0197377251851,83.3531381858158,40.0526272220744,10.5669983412898,27.2737698677103,79.4025562426586,93.7492135174305,57.2576002459118,93.8641341659927,60.1275910604504,98.8072447979464,76.4725017500014,19.3759709920787,52.1602305564330,64.3750574258589,87.0261391514952,60.4117185844663,99.9672685670308,13.7884537399418,30.0436937782654,48.2110579950285,13.8286607918277,23.5842230449644];
% x=[10.2671324642449,48.9493888101423,13.4326553364426,39.1487602740434,40.7284425139645,25.3996944395500,45.8704344291122,5.94819360677924,7.65540487186836,43.0575230051439];
% y=[1.91367775740347,36.6880709935992,41.0162355926352,6.69480203582243,24.9392626594674,18.0249719197885,38.9206589455762,14.9790500380037,41.3954387678638,9.47999303802817];
% x=[24.1143738599174,22.8329944810539,32.1142277803088,99.5473090990207,19.7240349921478,85.1986058677837,84.5465748962760,53.3033344231310,66.8222617969348,37.5920206838825,32.4263150123759,81.2220675525462,11.1597065687117,22.0635293447868,45.1957966019167,39.2685659767695,77.6901367626281,47.9488821280637,79.8823307150769,3.46108785916187,99.9148660458632,29.0222896833717,77.0146669210752,4.47130760802095,87.1655867692426,74.5515509757666,11.8200114419599,86.7950568683984,82.3310314423220,1.37538566220226,66.3660650531805,63.6041281351518,21.8376673525669,44.0597182840307,93.3778307105930,46.2709900595990,11.8928317330155,68.3092409183471,97.2014923303727,44.1023541702305,24.5579333900507,88.8546568839855,95.3243479926804,39.7738375974576,76.5694760763693,10.9052223092188,23.1623500392421,11.1452724270336,3.12067862666070,52.1758989952385,26.6099305422667,4.35639966911000,75.2185062413844,54.6295140898144,88.3128746441575,56.5776827059289,96.9003260735574,75.4950400773003,94.9790115422831,74.1425773146982];
% y=[27.0889763970983,9.66097252235100,68.9025770803232,81.2360221131169,15.9299213098763,32.0675490533215,49.2158136079441,70.6594714080047,60.0124350932196,6.38076436236476,97.1449827125499,57.8628458481490,57.8698585166160,58.1382564301970,60.4910756448909,14.4656183135610,4.45836651633456,41.9698450716154,28.0219831013866,69.2751941391140,98.5734884466719,25.4446234298344,76.8684867472883,66.9993236321881,54.0953273558404,90.1519371333473,67.0251318327207,54.7950930579824,9.83790993053169,3.75103700416415,96.0194853664650,73.4920701323456,89.1753329441036,89.6300543241569,79.6381073658328,53.9865497690565,34.8976731034757,28.7976644942798,47.9716840427002,1.84938414562895,43.0552242226033,72.0806880000100,41.6430639967525,60.8525445611747,59.4973540878902,97.8820027918649,28.3217318043119,5.23582783897271,87.1946821104653,88.8965926799148,37.8231074278072,15.7385196031036,17.7622088912029,17.1194660125399,59.9268418566535,85.2950882805235,5.36717030040338,59.4209900228916,25.5314599716884,22.6303978749984];


w=100;                              %检测区域的宽                              %静态节点数
l=100;
n=length(x)
r=5;                    %感知半径
theta=0:pi/100:2*pi; 
voronoi(x,y);axis([0 l 0 w])
hold on
[v,c]=voronoin([x;y]');
%v就是所有的voronoi边的顶点坐标，c{i}就是第i个点周围的voronoi边的顶点下标
for  i=1:1:n                        %for循环画出静态节点的感知圆
    fill(x(i)+r*cos(theta),y(i)+r*sin(theta),'b','EdgeColor','w','facealpha',0.2);%画圆
    hold on
    plot(x(i),y(i),'b.');
    voronoi(x,y);axis([0 l 0 w])
hold on
  figure(1)

  %hold on
%     plot(x(i),y(i),'b.');           %画静态节点
%     hold on
end
axis([0,l,0,w])
axis equal
%比如说第1个点(0,0)周围的voronoi边的顶点就是横坐标：v(c{1},1)，纵坐标：v(c{1},2)
%对于坐标为(inf,inf)的点就是无穷远点.
k_slove=[];
b_slove=[];
x_node_temp=[];
y_node_temp=[];
for n=1:n
disp(['点(' num2str(x(n)) ',' num2str(y(n)) ')周围的voronoi边的顶点的坐标是:'])
disp([v(c{n},1),v(c{n},2)])
disp(['点(' num2str(x(n)) ',' num2str(y(n)) ')周围的voronoi边的顶点的个数是:'])
a=[v(c{n},1),v(c{n},2)];
    for i=1:1:length(v(c{n}))               %循环每个静态节点形成的泰森多边形的各个顶点求出坐标
        if(i<length(v(c{n})))
            x0=a(i,1);
            y0=a(i,2);
            x1=a(i+1,1);
            y1=a(i+1,2);
                p1 = [x0 y0];
                p2 = [x1 y1];
                p3=[x(n) y(n)];
                l3=norm(p1-p2);                 %泰森多边形一个边的长度
                l1=norm(p3-p1);                 %静态节点到泰森多边形边的其中一端的距离
                l2=norm(p3-p2);                 %静态节点到泰森多边形边的另一端的距离
                k=(y1-y0)/(x1-x0);              %求出直线方程的K
                b=y0-k*x0;                                            %求出直线方程的b
            %%%%%%%%%%%%%%%%%%%%%%%%%%
            %此处应判断k_slove和b_slove中是否已经有对应的k和b，如果没有则进行下一步，如果有则跳过本次循环
            flog=0;
            for p=1:1:length(k_slove)                
                if(k_slove(p)==k&&b_slove(p)==b)
                    flog=1;
                end 
                if(l3<1.5)
                    flog=1;
                end 
            end
            if(flog==1)
                disp('这句话被执行了')
                continue
                
            end

            k_slove=[k_slove k];                                    %存储循环过程中产生的k
            b_slove=[b_slove b];                                    %存储循环过程中产生的b
            disp(['直线方程为：y=',num2str(k),'*x+',num2str(b)])     %求出直线方程
            d=abs((k*x(n)-y(n)+b)/sqrt(k*k+1));                     %点到直线的距离
            if(r<d)                                                 %判断两邻居节点的距离是否大于二倍的Rs
                al=acos(abs((l1*l1+l2*l2-l3*l3))/2*l1*l2);          %漏洞探测  计算圆心角
                fugailv=al*r*r/l3*d;                                %漏洞探测  计算覆盖率
                 disp(fugailv)
                    if(fugailv<0.9)                                 %漏洞探测  覆盖率小于百分之八十即修补漏洞
                        %此处修补漏洞
               %%%%%%%%%%%%%%%%%%%%%%%%%
               %disp(['点(' num2str(x_node) ',' num2str(y_node) ')是泰森多变行边上的点:'])
               disp(['点(' num2str(x(n)) ',' num2str(y(n)) ')是泰森多变行边上的点:'])
                        disp([x(n) y(n)])
                        disp([x0 y0])
                        disp([x1 y1])
            %%%%%%%%%%%%%%%%%%%%%%%%%%
                        a0=x(n);
                        a1=y(n);
                        b0=x0;
                        b1=y0;
                        c0=x1;
                        c1=y1;
                        Dab=sqrt((b0-a0)^2+(b1-a1)^2);      %计算角平分线与对边的交点
                        Dac=sqrt((c0-a0)^2+(c1-a1)^2);      %计算角平分线与对边的交点
                        value=Dab/Dac;                                  %计算角平分线与对边的交点
                        x_node=(b0+value*c0)/(1+value);                 %计算角平分线与对边的交点的横坐标
                        y_node=(b1+value*c1)/(1+value);                 %计算角平分线与对边的交点的纵坐标
                        
                        fleg=0;
                        for q=1:1:length(x_node_temp)                
                            if(x_node_temp(q)==x_node||y_node_temp(q)==y_node)
                                fleg=1;
                            end 
                        end
                        if(fleg==1)
                            continue
                        end
                        
                         x_node_temp=[x_node_temp x_node];                                  
                        y_node_temp=[y_node_temp y_node];
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                     disp(['点(' num2str(x_node) ',' num2str(y_node) ')是我们要找到的点:'])
                        %disp['这个是测试点aaaaaaaaaaa' num2str(y_node)]
                        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                        %                         disp('添加新节点');
                        disp('这句话没有执行到')
                            fill(x_node+r*cos(theta),y_node+r*sin(theta),'r','EdgeColor','w','facealpha',0.2);%画圆
                            hold on
                            plot(x_node,y_node,'k.');           %画静态节点
                            hold on
                            %%%%%%%%%%%%%%%
                            
                            %%%%%%%%%%%%%%%%
                        disp('这句话没有执行到')
                    end                                             %漏洞探测
            else
                    disp('此处R>d')   
            end                                                     %漏洞探测
%         flag=[flag l3];
            disp(a(i,1))
            disp(a(i,2))
            disp(a(i+1,1))
            disp(a(i+1,2))
%         else
%         disp(a(length(v(c{n})),1))
%         disp(a(length(v(c{n})),2))
        end
    end
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
axis([0,l,0,w])
for  i=1:1:n                        %for循环画出静态节点的感知圆
    fill(x(i)+r*cos(theta),y(i)+r*sin(theta),'b','EdgeColor','w','facealpha',0.2);%画圆
    hold on
    plot(x(i),y(i),'b.');
    voronoi(x,y);axis([0 l 0 w])
hold on
  figure(2)
  hold on
end
axis equal
axis([0,l,0,w])
x_x=[x x_node_temp];
y_y=[y y_node_temp];                   %感知半径
theta=0:pi/100:2*pi; 
figure(3)
voronoi(x_x,y_y);axis([0 l 0 w])
hold on
loop
